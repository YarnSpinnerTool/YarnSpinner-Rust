<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Yarn Spinner for Rust Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="yarn_files.html"><strong aria-hidden="true">2.</strong> Yarn Files</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="yarn_files/basics.html"><strong aria-hidden="true">2.1.</strong> Basics</a></li><li class="chapter-item expanded "><a href="yarn_files/running_examples.html"><strong aria-hidden="true">2.2.</strong> Running Examples</a></li><li class="chapter-item expanded "><a href="yarn_files/lines.html"><strong aria-hidden="true">2.3.</strong> Lines</a></li><li class="chapter-item expanded "><a href="yarn_files/variables.html"><strong aria-hidden="true">2.4.</strong> Variables</a></li><li class="chapter-item expanded "><a href="yarn_files/options.html"><strong aria-hidden="true">2.5.</strong> Options</a></li><li class="chapter-item expanded "><a href="yarn_files/nodes.html"><strong aria-hidden="true">2.6.</strong> Nodes</a></li><li class="chapter-item expanded "><a href="yarn_files/markup.html"><strong aria-hidden="true">2.7.</strong> Markup</a></li><li class="chapter-item expanded "><a href="yarn_files/functions.html"><strong aria-hidden="true">2.8.</strong> Functions</a></li><li class="chapter-item expanded "><a href="yarn_files/commands.html"><strong aria-hidden="true">2.9.</strong> Commands</a></li></ol></li><li class="chapter-item expanded "><a href="bevy_plugin.html"><strong aria-hidden="true">3.</strong> Bevy Plugin</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bevy_plugin/setup.html"><strong aria-hidden="true">3.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="bevy_plugin/compiling_yarn_files.html"><strong aria-hidden="true">3.2.</strong> Compiling Yarn Files</a></li><li class="chapter-item expanded "><a href="bevy_plugin/dialog_runner.html"><strong aria-hidden="true">3.3.</strong> DialogRunner and a High Level Overview</a></li><li class="chapter-item expanded "><a href="bevy_plugin/localization.html"><strong aria-hidden="true">3.4.</strong> Localization</a></li><li class="chapter-item expanded "><a href="bevy_plugin/assets.html"><strong aria-hidden="true">3.5.</strong> Assets</a></li><li class="chapter-item expanded "><a href="bevy_plugin/variable_storage.html"><strong aria-hidden="true">3.6.</strong> Variable Storage</a></li><li class="chapter-item expanded "><a href="bevy_plugin/custom_functions.html"><strong aria-hidden="true">3.7.</strong> Custom Functions</a></li><li class="chapter-item expanded "><a href="bevy_plugin/custom_commands.html"><strong aria-hidden="true">3.8.</strong> Custom Commands</a></li><li class="chapter-item expanded "><a href="bevy_plugin/dialog_views.html"><strong aria-hidden="true">3.9.</strong> Dialog Views</a></li></ol></li><li class="chapter-item expanded "><a href="working_without_bevy.html"><strong aria-hidden="true">4.</strong> Working without Bevy</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Yarn Spinner for Rust Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/YarnSpinnerTool/YarnSpinner-Rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="yarn-spinner-for-rust-book"><a class="header" href="#yarn-spinner-for-rust-book">Yarn Spinner for Rust Book</a></h1>
<p>Welcome to Yarn Spinner for Rust, the friendly dialogue tool for Rust!
Yarn Spinner for Rust is a port of the widely used dialogue tool <a href="https://yarnspinner.dev">Yarn Spinner</a>.</p>
<p>Please click on the link that describes your situation the best.</p>
<ul>
<li><a href="./yarn_files.html">I'm new to all of this</a></li>
<li><a href="./bevy_plugin.html">I have used Yarn Spinner for Unity before</a></li>
<li><a href="./working_without_bevy">I want to work without Bevy</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yarn-files"><a class="header" href="#yarn-files">Yarn Files</a></h1>
<p>Yarn Spinner for Rust is a port of the widely used dialogue tool <a href="https://yarnspinner.dev/">Yarn Spinner</a>.
They both share the idea of writing dialog in writer-friendly text files called Yarn files.</p>
<p>This chapter greatly overlaps with the following Yarn Spinner documentation chapters, so feel free to check these
out as well:</p>
<ul>
<li><a href="https://docs.yarnspinner.dev/getting-started/writing-in-yarn">Writing in Yarn</a></li>
<li><a href="https://docs.yarnspinner.dev/getting-started/editing-with-vs-code">Editing with VS Code</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>Yarn Spinner stores its dialogue in <em>Yarn files</em>. These look a bit like play scripts or movie scripts.
Here is an example that might be called <code>hello_world.yarn</code>:</p>
<pre><code class="language-text">title: Start
---
Hello World!
===
</code></pre>
<p>Simple, right? Let's go through it line-by-line.</p>
<ul>
<li>Yarn files are organized in <em>nodes</em>. The first line in this script, <code>title: Start</code>,
tells us that this is the start of the node named <code>Start</code>. We call this kind of information a <code>header</code>.</li>
<li>The line <code>---</code> separates the headers from the <em>body</em>.</li>
<li><code>Hello World</code> is the text that will be shown to the player.</li>
<li><code>===</code> marks the end of the node.</li>
</ul>
<p>And that's the whole file! If you run this node, you will get a dialogue box with the text "Hello World!".</p>
<p>In the next chapter, we will look at how you can run examples along.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-examples"><a class="header" href="#running-examples">Running Examples</a></h1>
<p>You can run Yarn files by copy-pasting them into <a href="https://try.yarnspinner.dev">Try Yarn Spinner</a>.
This is nice because it runs directly in your browser and so doesn't require any setup. Since Yarn Spinner
and Yarn Spinner read Yarn files the same way, the behavior will be identical to how it would be in your game.
The only thing to look out for is that Try Yarn Spinner will only start at a node named "Start".</p>
<p>If you want to see the result of your Yarn files in an actual game window, you can
setup a little example project. We will use screenshots from such a setup throughout the book.</p>
<p>If you want to follow along this way setup the crate by running the following commands.</p>
<pre><code class="language-bash">cargo new yarnspinner_playground
cd yarnspinner_playground
cargo add bevy --features filesystem_watcher
cargo add bevy_yarnspinner bevy_yarnspinner_example_dialogue_view
</code></pre>
<p>Then, in your <code>src/main.rs</code>, add the following code:</p>
<pre><pre class="playground"><code class="language-rust">// src/main.rs
use bevy::{prelude::*, asset::ChangeWatcher, utils::Duration};
use bevy_yarnspinner::prelude::*;
use bevy_yarnspinner_example_dialogue_view::prelude::*;

fn main() {
    let mut app = App::new();

    app.add_plugins((
        DefaultPlugins.set(AssetPlugin {
            watch_for_changes: ChangeWatcher::with_delay(Duration::from_millis(200)),
            ..default()
        }),
        YarnSpinnerPlugin::new(),
        ExampleYarnSpinnerDialogueViewPlugin::new(),
    ))
    .add_systems(Startup, setup_camera)
    .add_systems(
        Update,
        spawn_dialogue_runner.run_if(resource_added::&lt;YarnProject&gt;()),
    )
    .run();
}

fn setup_camera(mut commands: Commands) {
    commands.spawn(Camera2dBundle::default());
}

fn spawn_dialogue_runner(mut commands: Commands, project: Res&lt;YarnProject&gt;) {
    let mut dialogue_runner = project.create_dialogue_runner();
    dialogue_runner.start_node("Start");
    commands.spawn(dialogue_runner);
}</code></pre></pre>
<p>Don't worry, we will look at what this code does in detail later, in the chapter <a href="yarn_files/../bevy_plugin/setup.html">Bevy Plugin / Setup</a>.
For now, just treat it as something that runs your Yarn files.</p>
<p>Finally, add your Yarn files to the assets. Inside the folder <code>assets/dialogue</code>, add a file named <code>example.yarn</code> with the content
you want to run. Let's use the example from the last chapter:</p>
<pre><code class="language-text"># assets/dialogue/example.yarn
title: Start
---
Hello World!
===
</code></pre>
<p>Your file structure should now look like this:</p>
<p><img src="yarn_files/file_system.png" alt="file_system.png" /></p>
<p>Run your game with <code>cargo run</code> and you should see the following:</p>
<p><img src="yarn_files/hello_world.png" alt="hello_world.png" /></p>
<p>It might have taken a while to compile, but the good news is that the code you're running now
supports <em>hot reloading</em>, which means that you can change your Yarn file and save it while the game is running
and the changes will be visible immediately, as long as you didn't already close the dialog by completing it.
No recompilation required!</p>
<p>Try it out now. Can you make the dialogue say "Goodbye World!" instead?
What happens when write the text as if a character spoke it, e.g. "Narrator: Hello World!"?</p>
<p>In the next chapters, we are going to take a closer look at what you can write inside a Yarn file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lines"><a class="header" href="#lines">Lines</a></h1>
<p>As you might have figured out by playing around with the file from last chapter, a <em>line</em>
can be spoken by a character. The following Yarn file...</p>
<pre><code class="language-text">title: Start
---
Narrator: Hello World!
===
</code></pre>
<p>Results in this dialogue window:
<img src="yarn_files/narrator.png" alt="narrator.png" /></p>
<p>Notice how the character name, in this case "Narrator", appears on the upper left corner of the dialogue box.</p>
<p>Every new line in the file is interpreted as a new line in the dialogue. Try running the following:</p>
<pre><code class="language-text">title: Start
---
Narrator: Hello World!
Narrator: How are you?
Player: I'm fine, thanks!
And everyone lived happily ever after.
===
</code></pre>
<p>If you're running the example in Yarn Spinner, you can advance the dialogue
by pressing the space bar, enter key, clicking the mouse, or tapping the screen. Remember that you can
change the Yarn file while the game is running, so no need to restart the program!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Values can be stored in variables. A new variable is declared with the <code>&lt;&lt;declare&gt;&gt;</code> command:</p>
<pre><code class="language-text">title: Start
---
&lt;&lt;declare $name = "Ferris"&gt;&gt;
===
</code></pre>
<p>They can be used within text by surrounding them with curly braces (<code>{}</code>):</p>
<pre><code class="language-text">title: Start
---
&lt;&lt;declare $name = "Player"&gt;&gt;
&lt;&lt;declare $age = 26&gt;&gt;
Ferris: Hello, {$name}! I heard you are {$age} years old!
===
</code></pre>
<p>This will be displayed as:</p>
<p><img src="yarn_files/variables.png" alt="variables.png" /></p>
<p>You can change the value of a variable with the <code>&lt;&lt;set&gt;&gt;</code> command:</p>
<pre><code class="language-text">title: Start
---
&lt;&lt;declare $name = "Player"&gt;&gt;
&lt;&lt;declare $age = 26&gt;&gt;
Ferris: Hello, {name}! I heard you are {$age} years old!
One year later...
&lt;&lt;set $age = $age + 1&gt;&gt;
Ferris: Hello, {name}! Wow, you're {$age} years old now! Time sure flies, eh?
===
</code></pre>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<p>Variables can have the following types:</p>
<ul>
<li><code>string</code>: A string of characters, like <code>"Hello World!"</code>.</li>
<li><code>number</code>: A number, like <code>42</code>, <code>0</code>, <code>-99999</code>, <code>3.1415</code>, or <code>6.0</code>.</li>
<li><code>boolean</code>: Either <code>true</code> or <code>false</code>.</li>
</ul>
<p>All variable names must start with a <code>$</code> and can only contain letters, numbers, and underscores (<code>_</code>).</p>
<h2 id="conditional-lines"><a class="header" href="#conditional-lines">Conditional lines</a></h2>
<p>Boolean variables or conditions can be used to only show lines according to a condition:</p>
<pre><code class="language-text">title: Start
---
&lt;&lt;declare $apples = 3&gt;&gt;
&lt;&lt;if $apples &gt; 2&gt;&gt;
Apple Aficionado: Woah, that's a lot of apples!
&lt;&lt;elseif $apples &gt; 1&gt;&gt;
Apple Aficionado: Congrats, that's an appropriate amount of apples.
&lt;&lt;else&gt;&gt;
Apple Aficionado: You should get more apples.
&lt;&lt;endif&gt;&gt;
===
</code></pre>
<p>This Yarn file will result in dialog that only prints the first line:
<img src="yarn_files/apples.png" alt="apples.png" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="options"><a class="header" href="#options">Options</a></h1>
<p>The syntax for asking the player to make a choice looks like this:</p>
<pre><code class="language-text">title: Start
---
Ferris: So, how's life these days?
-&gt; Pretty good, actually.
-&gt; Could be better.
===
</code></pre>
<p>This results in the following dialogue window:</p>
<p><img src="yarn_files/options.png" alt="options.png" /></p>
<p>By indenting the lines after an option, you can selectively branch a dialogue:</p>
<pre><code class="language-text">title: Start
---
Ferris: So, how's life these days?
-&gt; Pretty good, actually.
    Ferris: That's great to hear!
-&gt; Could be better.
    Ferris: Oh no! What's wrong?
===
</code></pre>
<p>In this example, the character "Ferris" will only answer with "That's great to hear!" if the player chooses the first option.
This can also be used to conditionally set variables:</p>
<pre><code class="language-text">title: Start
---
Ferris: So, how's life these days?
&lt;&lt;declare $mood = ""&gt;&gt;
-&gt; Pretty good, actually.
    &lt;&lt;set $mood = "good"&gt;&gt;
-&gt; Could be better.
    &lt;&lt;set $mood = "bad"&gt;&gt;
Ferris: I see. So you're feeling {$mood}?
===
</code></pre>
<p>You can also nest options within options:</p>
<pre><code class="language-text">title: Start
---
Ferris: So, how's life these days?
-&gt; Pretty good, actually.
    Ferris: That's great to hear!
    -&gt; I know, right?
        Ferris: Yeah!
-&gt; Could be better.
    Ferris: Oh no! What's wrong?
    -&gt; I don't want to talk about it.
        Ferris: Okay, that's fine.
    -&gt; I'm just tired.
        Ferris: I know how that feels.
===
</code></pre>
<p>Notice how it's valid to leave the player only one option to choose from, as seen after Ferris says "That's great to hear!".</p>
<p>Unindented lines after options will be executed no matter which option the player chooses:</p>
<pre><code class="language-text">title: Start
---
Shopkeeper: Welcome to my shop! What can I do for you?
-&gt; I'd like to buy apples
-&gt; I'd like to buy oranges
Shopkeeper: Here you go!
===
</code></pre>
<p>Finally, boolean <a href="yarn_files/variables.html">variables</a> can be used to determine whether an option should be available or not:</p>
<pre><code class="language-text">title: Start
---
Shopkeeper: Welcome to my shop! What can I do for you?
&lt;&lt;declare $eats_meat = false&gt;&gt;
-&gt; I'd like to buy apples
-&gt; I'd like to buy oranges
-&gt; I'd like to buy salami &lt;&lt;if $eats_meat&gt;&gt;
===
</code></pre>
<p>The above file will result in the following dialogue window:</p>
<p><img src="yarn_files/cond_options.png" alt="cond_options.png" /></p>
<p>Keeping the disabled options hidden is the behavior of the <a href="yarn_files/../bevy_plugin/dialog_views.html">dialogue view</a> used here,
but these options are delivered to the view, which means you could still show them to the user
in e.g. a greyed-out state.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodes"><a class="header" href="#nodes">Nodes</a></h1>
<p>In the last chapters, we have so far only used a single node named "Start".
We will now use multiple nodes and <code>jump</code> between them to compose a more complex dialogue:</p>
<pre><code class="language-text">title: Start
---
Ferris: Say, do you want to go on an adventure?
-&gt; Aye aye!
    Ferris: Great, let's go!
    &lt;&lt;jump Adventure&gt;&gt;
-&gt; No thanks.
    Ferris: Okay, that's fine.
    &lt;&lt;jump GoodBye&gt;&gt;
===

title: Adventure
---
Narrator: And so, the two friends went on an adventure.
Dictionary: timeskip (pl. timeskips)(fandom slang): An instance of fast-forwarding a substantial amount of time, such as years or decades, as a narrative device in a story, quickly aging characters and developing events.
Ferris: Wow, that was a great adventure!
&lt;&lt;jump GoodBye&gt;&gt;
===

title: GoodBye
---
Narrator: And everyone lived happily ever after.
===
</code></pre>
<p>Here we've got three nodes: "Start", "Adventure", and "GoodBye". We jump between them using the <code>jump</code> command.
You can see that we always arrive at the node "GoodBye", but optionally go through the node "Adventure" first.
If you're editing your Yarn file using Visual Studio Code and have the Yarn Spinner extension installed,
you can display this flow in a graph by clicking the "Show Graph" button in the upper right corner, which will show you something like this:
<img src="yarn_files/graph.png" alt="graph.png" /></p>
<p>It is allowed to jump to your current node:</p>
<pre><code class="language-text">title: Start
---
Ferris: Say, do you want to go on an adventure?
-&gt; Aye aye!
    Ferris: Great, let's go!
-&gt; No thanks.
    Ferris: Pretty please?
    &lt;&lt;jump Start&gt;&gt;
===
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="markup"><a class="header" href="#markup">Markup</a></h1>
<p>TODO (Feel free to <a href="https://github.com/YarnSpinnerTool/YarnSpinner-Rust/edit/main/docs/src/yarn_files/markup.md">contribute</a>!)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Function calls look like this:</p>
<pre><code class="language-text">title: Start
---
I rolled a die and got a {dice(6)}!
===
</code></pre>
<p>Which will result in something like this:</p>
<p><img src="yarn_files/dice.png" alt="dice.png" /></p>
<p>The curly braces (<code>{}</code>) are not part of the function call, but are used to interpolate the result of the function into the text,
as seen previously in the chapter <a href="yarn_files/variables.html">Variables</a>.</p>
<p>Speaking about variables, you can also use them as parameters:</p>
<pre><code class="language-text">title: Start
---
&lt;&lt;declare $sides = 0&gt;&gt;
How many sides does your die have?
-&gt; One
    &lt;&lt;set $sides = 1&gt;&gt;
-&gt; Six
    &lt;&lt;set $sides = 6&gt;&gt;
-&gt; Six thousand
    &lt;&lt;set $sides = 6000&gt;&gt;
Rolling a die with {$sides} sides and got a {dice($sides)}!
===
</code></pre>
<p>There are a number of built-in functions available, such as the <code>dice</code> function used above.
Defining your own functions is specific to the game engine used.
For Bevy, see the chapter <a href="yarn_files/../bevy_plugin/custom_functions.html">Custom Functions</a>.</p>
<p>The following functions are available by default in all game engines:</p>
<h2 id="random"><a class="header" href="#random">Random</a></h2>
<ul>
<li><code>dice(sides)</code>: Simulates a <code>sides</code>-sided die roll, i.e. returns a random number between 1 and <code>sides</code>, inclusive.</li>
<li><code>random()</code>: Returns a random real number between 0 and 1.</li>
<li><code>random_range(min, max)</code>: Returns a random integer between <code>min</code> and <code>max</code>, inclusive.
If either <code>min</code> or <code>max</code> is not an integer, the generated number will instead be a real number between <code>min</code> and <code>max</code>.</li>
</ul>
<h2 id="visited-nodes"><a class="header" href="#visited-nodes">Visited nodes</a></h2>
<ul>
<li><code>visited(node)</code>: Returns <code>true</code> if the node named <code>node</code> exists and has been visited and exited before, <code>false</code> otherwise.</li>
<li><code>visited_count(node)</code>: Returns the number of times the node named <code>node</code> has been visited and exited.</li>
</ul>
<h2 id="type-casts"><a class="header" href="#type-casts">Type casts</a></h2>
<ul>
<li><code>string(value)</code>: Returns the string representation of <code>value</code>.</li>
<li><code>number(value)</code>: Returns the number representation of <code>value</code>.</li>
<li><code>bool(value)</code>: Returns the boolean representation of <code>value</code>.</li>
</ul>
<h2 id="number-manipulation"><a class="header" href="#number-manipulation">Number manipulation</a></h2>
<ul>
<li><code>round(n)</code>: Rounds <code>n</code> to the nearest integer.</li>
<li><code>round_places(n, places)</code>: Rounds <code>n</code> to the nearest integer with <code>places</code> decimals.</li>
<li><code>floor(n)</code>: Rounds <code>n</code> down to the nearest integer.</li>
<li><code>ceil(n)</code>: Rounds <code>n</code> up to the nearest integer.</li>
<li><code>inc(n)</code>: Returns <code>n + 1</code> if <code>n</code> is an integer, otherwise rounds <code>n</code> up to the nearest integer.</li>
<li><code>dec(n)</code>: Returns <code>n - 1</code> if <code>n</code> is an integer, otherwise rounds <code>n</code> down to the nearest integer.</li>
<li><code>decimal(n)</code>: Returns the decimal part of <code>n</code>. This is guaranteed to return a number between 0.0 and 1.0, e.g. <code>decimal(3.14)</code> returns <code>0.14</code>.</li>
<li><code>int(n)</code>: Returns the integer part of <code>n</code>, e.g. <code>int(3.14)</code> returns <code>3</code> and <code>int(-3.14)</code> returns <code>-3</code>.
This effectively means that the number is rounded towards the nearest integer toward zero.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>You've seen the <code>&lt;&lt;something something&gt;&gt;</code> syntax a couple of times now.
Everything that happens between the double angle brackets (<code>&lt;&lt;</code> &amp; <code>&gt;&gt;</code>) is called a <em>command</em>.</p>
<p>Commands serve either fundamental operations such as declaring new <a href="yarn_files/variables.html">variables</a> or instructing the game engine to
manipulate the world somehow. A command takes up an entire line.
In contrast to <a href="yarn_files/functions.html">functions</a>, commands return no value and can thus not be used within lines via interpolation.</p>
<p>Defining your own commands is specific to the game engine used.
For Bevy, see the chapter <a href="yarn_files/../bevy_plugin/custom_commands.html">Custom Commands</a>.</p>
<p>The following commands are available by default in all game engines:</p>
<h2 id="variables-1"><a class="header" href="#variables-1">Variables</a></h2>
<ul>
<li><code>&lt;&lt;declare $variable = initial_value&gt;&gt;</code>: Creates a new variable and initializes it with a value.</li>
<li><code>&lt;&lt;set $variable = new_value&gt;&gt;</code>: Assigns a new value to an existing variable.</li>
</ul>
<h2 id="flow-control"><a class="header" href="#flow-control">Flow control</a></h2>
<ul>
<li><code>&lt;&lt;if $condition&gt;&gt;</code> / <code>&lt;&lt;elseif $condition&gt;&gt;</code> / <code>&lt;&lt;else&gt;&gt;</code> / <code>&lt;&lt;endif&gt;&gt;</code>: Executes lines conditionally. In <a href="yarn_files/options.html">options</a>, place <code>&lt;&lt;if $foo&gt;&gt;</code> at the end of the line.</li>
<li><code>&lt;&lt;stop&gt;&gt;</code>: Immediately ends the dialog as if it ran out of lines.</li>
</ul>
<h2 id="engine-communication"><a class="header" href="#engine-communication">Engine communication</a></h2>
<ul>
<li><code>&lt;&lt;wait $seconds&gt;&gt;</code>: Waits for <code>$seconds</code> seconds before continuing the dialog, e.g. <code>wait 3.5</code> will wait for 3.5 seconds.
This will not block the game engine, so the rest of the game can continue running in the meantime, presumably without the player gaining control.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-plugin"><a class="header" href="#bevy-plugin">Bevy Plugin</a></h1>
<p>While Yarn Spinner for Rust is built to be engine-agnostic, the intended way to use it
is through an engine-specific wrapper. The currently only supported engine is <a href="https://bevyengine.org/">Bevy</a>.
It is a data-oriented game engine using an ECS, which broadly means that you don't look at your game world
through the traditional lens of objects mutating the world and each other, but instead see the game as a collection
of data attached to various entities that can be queried and manipulated through systems.</p>
<p>This chapter will assume that you are familiar with the basics of Bevy. If you're not there not,
try to come back after you've gone through the <a href="https://bevyengine.org/learn/book/introduction/">Bevy Book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>We will now go through the steps to setup a new Bevy project running Yarn Spinner dialogs.
This is the same setup as in the chapter <a href="bevy_plugin/../yarn_files/running_examples.html">Running Examples</a>, but with explanations this time.
If you've followed along in the linked chapter already, you can just read this part without executing anything.</p>
<h2 id="setting-up-the-crate"><a class="header" href="#setting-up-the-crate">Setting up the crate</a></h2>
<p>Run the following in your terminal to create a new crate with the required dependencies:</p>
<pre><code class="language-bash">cargo new yarnspinner_playground
cd yarnspinner_playground
cargo add bevy --features file_watcher
cargo add bevy_yarnspinner bevy_yarnspinner_example_dialogue_view
</code></pre>
<p>The line <code>cargo add bevy --features filesystem_watcher</code> ensures that we can use <em>hot reloading</em> in our project, which means that we can edit the Yarn files
while the game is running and it will reload them automatically on change.</p>
<p>The dependency <code>bevy_yarnspinner</code> is for the Yarn Spinner Bevy plugin proper, while <code>bevy_yarnspinner_example_dialogue_view</code>
gives us a nice default <a href="bevy_plugin/dialog_views.html">dialog view</a>, so we can actually see the text we've written and have options to click on.</p>
<h2 id="adding-the-yarn-files"><a class="header" href="#adding-the-yarn-files">Adding the Yarn Files</a></h2>
<p>We'll use a single Yarn file for this example. Inside the folder <code>assets/dialog</code>, add a file named <code>example.yarn</code> with the following content:</p>
<pre><code class="language-text"># assets/dialogue/example.yarn
title: Start
---
Hello World!
===
</code></pre>
<h2 id="the-main-code"><a class="header" href="#the-main-code">The main code</a></h2>
<p>Add the following code to your <code>src/main.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust">// src/main.rs
use bevy::{prelude::*, asset::ChangeWatcher, utils::Duration};
use bevy_yarnspinner::prelude::*;
use bevy_yarnspinner_example_dialogue_view::prelude::*;

fn main() {
    let mut app = App::new();
    app.add_plugins((
        DefaultPlugins.set(AssetPlugin {
            // Activate hot reloading
            watch_for_changes: ChangeWatcher::with_delay(Duration::from_millis(200)),
            ..default()
        }),
        // Add the Yarn Spinner plugin. 
        // As soon as this plugin is built, a Yarn project will be compiled 
        // from all Yarn files found under assets/dialog/*.yarn
        YarnSpinnerPlugin::new(),
        // Add the example dialogue view plugin
        ExampleYarnSpinnerDialogueViewPlugin::new(),
    ))
    // Setup a 2D camera so we can see the text
    .add_systems(Startup, setup_camera)
    // Spawn the dialog as soon as the Yarn project finished compiling
    .add_systems(
        Update,
        spawn_dialogue_runner.run_if(resource_added::&lt;YarnProject&gt;()),
    )
    .run();
}

fn setup_camera(mut commands: Commands) {
    commands.spawn(Camera2dBundle::default());
}

fn spawn_dialogue_runner(mut commands: Commands, project: Res&lt;YarnProject&gt;) {
    let mut dialogue_runner = project.create_dialogue_runner();
    // Start the dialog at the node with the title "Start"
    dialogue_runner.start_node("Start");
    commands.spawn(dialogue_runner);
}</code></pre></pre>
<p>Reiterating the comments in the code, let's take a look at some snippets.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>DefaultPlugins.set(AssetPlugin {
    // Activate hot reloading
    watch_for_changes: ChangeWatcher::with_delay(Duration::from_millis(200)),
    ..default()
}),
<span class="boring">}</span></code></pre></pre>
<p>This setting for the <code>AssetPlugin</code> enables you to edit the Yarn files on the fly while your game is running and
see the effects instantaneously. We recommend using this workflow on all platforms which support it, which is to say all except Wasm and Android.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>YarnSpinnerPlugin::new(),
<span class="boring">}</span></code></pre></pre>
<p>This self-explanatory line initializes the plugin. When using the standard constructor with no options, Yarn files will be searched for in the directory <code>&lt;your game&gt;/assets/dialog/</code>, where all
files ending in <code>.yarn</code> will be compiled as soon as the game starts.</p>
<p>The plugin makes sure all components of Yarn Spinner work except for any actual graphics. You need to
instantiate a <a href="bevy_plugin/dialog_views.html">dialog view</a> for that:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ExampleYarnSpinnerDialogueViewPlugin::new(),
<span class="boring">}</span></code></pre></pre>
<p>Here we initialize the dialogue view shipped by the <code>bevy_yarnspinner_example_dialogue_view</code> crate. It
offers some sensible defaults which you can see in the screenshots used throughout this guide. You can of course skip this
and use your own dialogue view instead.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>spawn_dialogue_runner.run_if(resource_added::&lt;YarnProject&gt;()),
<span class="boring">}</span></code></pre></pre>
<p>The method <code>.run_if(resource_added::&lt;YarnProject&gt;()</code> is our way of saying "run this system once as soon as our Yarn files are done compiling".
Let's look at what will actually be run in that moment:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_dialogue_runner(mut commands: Commands, project: Res&lt;YarnProject&gt;) {
    let mut dialogue_runner = project.create_dialogue_runner();
    // Start the dialog at the node with the title "Start"
    dialogue_runner.start_node("Start");
    commands.spawn(dialogue_runner);
}
<span class="boring">}</span></code></pre></pre>
<p>The main way of interacting with Yarn files during runtime and managing the flow of a dialog is through a
<a href="bevy_plugin/dialog_runner.html"><code>DialogRunner</code></a>. To do this, we use the <a href="bevy_plugin/compiling_yarn_files.html"><code>YarnProject</code></a> resource we referenced in the <code>run_if</code> section above.
It represents our compiled Yarn files, which we use to create a new dialog runner.<br />
We then point it to the <a href="bevy_plugin/../yarn_files/nodes.html">node</a> named "Start" of our Yarn file.
We use <code>start_node</code> for this, which will "move" the dialog runner to the provided node and start executing the dialog in the next frame,
using the registered dialog view to actually present it on the screen.<br />
Finally, we spawn the dialog runner on an own entity into the Bevy world.</p>
<p>In the end, your file structure should look like this:</p>
<p><img src="bevy_plugin/../yarn_files/file_system.png" alt="file_system.png" /></p>
<p>Run your game with <code>cargo run</code> and you should see the following:</p>
<p><img src="bevy_plugin/../yarn_files/hello_world.png" alt="hello_world.png" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiling-yarn-files"><a class="header" href="#compiling-yarn-files">Compiling Yarn Files</a></h1>
<p>The <code>YarnProject</code> resource represents the set of all compiled Yarn files of
your game. You cannot construct it yourself. Instead, it is inserted into the Bevy world for
you when the compilation is finished. You can however steer how and when this is done.</p>
<h2 id="starting-the-compilation-process"><a class="header" href="#starting-the-compilation-process">Starting the Compilation Process</a></h2>
<p>Generally, you'll want your game to compile the Yarn files as soon as possible. This
is why the <a href="bevy_plugin/setup.html"><code>YarnSpinnerPlugin</code></a> will start doing so by default when it is added to the app.</p>
<p>If for some reason you do not wish to start compilation right away, you can <em>defer</em> this process. To do this,
construct the <code>YarnSpinnerPlugin</code> with <code>YarnSpinnerPlugin::deferred()</code> when adding it. Then, whenever you are ready
to start the compilation, you can send a <code>LoadYarnProjectEvent</code>. Its construction methods are identical to the <code>YarnSpinnerPlugin</code>.
In fact, when not running in deferred mode, the <code>YarnSpinnerPlugin</code> simply relays its setting to a <code>LoadYarnProjectEvent</code> and sends it.</p>
<h2 id="settings"><a class="header" href="#settings">Settings</a></h2>
<p>If you look through the documentation of the [<code>YarnSpinnerPlugin</code>], you'll notice a few methods to modify
its settings. The first few deal with where our Yarn files are coming from.</p>
<h3 id="yarn-file-sources"><a class="header" href="#yarn-file-sources">Yarn File Sources</a></h3>
<p>By default, Yarn Spinner will look
in <code>&lt;game directory&gt;/assets/dialog</code>. Yarn Spinner can only read files from the <code>assets</code> directory
— or its equivalent, if you have changed this default in the <code>AssetPlugin</code> on platforms which support it—
but you can change how the <code>assets</code> will be looked through.</p>
<p>The way to specify this is via <code>YarnFileSource</code>s. This enum tells Yarn Spinner where one or more Yarn files
come from and can be added to an <code>AssetPlugin</code> with <code>AssetPlugin::add_yarn_source()</code>.
The enum variants should be self explanatory, but the two most common use-cases come with their own convenience constructors:</p>
<ul>
<li><code>YarnFileSource::file()</code>: looks for a Yarn file at a path inside under the <code>assets</code> directory.</li>
<li><code>YarnFileSource::folder()</code>: recursively looks through a given subdirectory for Yarn files.</li>
</ul>
<p>Since the Wasm and Android builds of Bevy have restrictions on their filesystem access,
they cannot use <code>YarnFileSource::folder()</code> and must have all their Yarn files listed explicitly with <code>YarnFileSource::file()</code>.
As such, the default behavior provided by <code>YarnSpinnerPlugin::new()</code> is not suitable for these platforms.
To avoid it, use the <code>AssetPlugin::with_yarn_source()</code> constructor instead.</p>
<p>As you might have guessed by now, <code>YarnSpinnerPlugin::new()</code> is simply a shorthand for <code>AssetPlugin::with_yarn_source(YarnFileSource::folder("dialog"))</code>.</p>
<h3 id="development-file-generation"><a class="header" href="#development-file-generation">Development File Generation</a></h3>
<p><code>YarnSpinnerPlugin::with_development_file_generation()</code> accepts a <code>DevelopmentFileGeneration</code>, which tells Yarn Spinner how aggressively to generate useful files on runtime.
"Useful" refers to the developer and not the user. The default is <code>DevelopmentFileGeneration::TRY_FULL</code>, which will be <code>DevelopmentFileGeneration::Full</code> on platforms which support filesystem access,
i.e. all except Wasm and Android. See the documentation for the full list of effects. Suffice it to say
that this is not very important when developing without localization, but becomes vital otherwise. See the <a href="bevy_plugin/localization.html">Localization</a> chapter for more.</p>
<p>Since these settings are intended for development, you can use <code>YarnSpinnerPlugin::with_development_file_generation(DevelopmentFileGeneration::None)</code> when shipping your game to optimize the runtime costs and
avoid generating files that are useless to the player.</p>
<h3 id="localization"><a class="header" href="#localization">Localization</a></h3>
<p>The settings accessed by <code>YarnSpinnerPlugin::with_localizatons</code> are important enough to warrant their own chapter. See <a href="bevy_plugin/localization.html">Localization</a>.</p>
<h2 id="after-the-compilation"><a class="header" href="#after-the-compilation">After the Compilation</a></h2>
<p>Whether you used <code>YarnSpinnerPlugin</code> or <code>LoadYarnProjectEvent</code>, as soon as the compilation finished, a <code>YarnProject</code> resource will be inserted into the Bevy world.
You can react to its creation by guarding your systems with <code>.run_if(resource_added::&lt;YarnProject&gt;())</code>, as seen in the <a href="bevy_plugin/setup.html">setup</a>.</p>
<p>Once you have the <code>YarnProject</code>, you can use it to spawn a <code>DialogRunner</code> which in turn can, well, <a href="bevy_plugin/dialog_runner.html">run dialogs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dialogrunner-and-a-high-level-overview"><a class="header" href="#dialogrunner-and-a-high-level-overview"><code>DialogRunner</code> and a High Level Overview</a></h1>
<p>The main way to actually manipulate the state of your dialog is through a <code>DialogRunner</code>.
You create it from a <code>YarnProject</code> (see <a href="bevy_plugin/compiling_yarn_files.html">Compiling Yarn Files</a>) with either
<code>YarnProject::create_dialog_runner()</code> or <code>YarnProject::build_dialog_runner()</code>.
The first uses default configurations which should be alright for many use-cases,
while the latter allows you to add or change functionality.</p>
<h2 id="dialog-flow"><a class="header" href="#dialog-flow">Dialog Flow</a></h2>
<p>The actual navigation through a dialog is handled by a <a href="bevy_plugin/dialog_views.html">dialog view</a>,
which is responsible for back-and-forth interaction with the player.
As such, most of the methods provided by a <code>DialogRunner</code> are to be called by such a view.
The one you will want to call yourself, as seen in the <a href="bevy_plugin/setup.html">setup</a>, is <code>DialogRunner::start_node</code>,
which will tell the <code>DialogRunner</code> to start running from the provided <a href="bevy_plugin/../yarn_files/nodes.html">node</a>.</p>
<h2 id="variable-storage"><a class="header" href="#variable-storage">Variable Storage</a></h2>
<p><a href="bevy_plugin/../yarn_files/variables.html">Variables</a> need to be stored in some place. By default, they are kept in memory through the <code>InMemoryVariableStorage</code>.
This means that when you quit and reopen the game, all variables used in Yarn files will be empty again. Of course, this is suboptimal when you want to allow
the player saving and loading their game state. To accomplish this, you can go one of two routes:</p>
<ul>
<li>Manipulate the variables in the variable store. Read then when saving and write them when loading.
You can access the variable storage through <code>DialogRunner::variable_storage()</code>.</li>
<li>Directory use a variable storage that stores its variables in a persistent way, such as a database or a file.
You can change the underlying variable storage through the builder API discussed later in this chapter.</li>
</ul>
<p>For information on how to create your own variable storage, see the chapter <a href="bevy_plugin/./variable_storage">Variable Storage</a></p>
<h2 id="functions-and-commands"><a class="header" href="#functions-and-commands">Functions and Commands</a></h2>
<p>Yarn files can contain user-defined functions and commands. These can be accessed with
<code>DialogRunner::library()</code> and <code>DialogRunner::commands()</code>. For more information, see the chapters <a href="bevy_plugin/custom_functions.html">Custom Functions</a>
and <a href="bevy_plugin/custom_commands.html">Custom Commands</a>.</p>
<h2 id="text-and-assets"><a class="header" href="#text-and-assets">Text and Assets</a></h2>
<p>We make a distinction between <em>text</em>, which are the written words organized into <em>lines</em> contained in Yarn files or in
<a href="bevy_plugin/localization.html">localization files</a>, and <em>assets</em>, which are supplemental data associated with a line.
Assets are referenced over a Bevy <code>Handle</code> and can be used for things such as voiceover sound files or images that might need translation.</p>
<p>Of note is that using assets <strong>requires</strong> using <a href="bevy_plugin/localization.html">localization</a>, or at least thinking about it.
As a consequence, language settings are split between text and assets. After all, a player might want to hear lines delivered in the original recorded language but read the text translated into their own language.</p>
<p>You can read more about how current language can be set for a <code>DialogRunner</code> in the <a href="bevy_plugin/localization.html">localization</a> chapter.</p>
<p>Text is provided by a <code>TextProvider</code>. While it can be overwritten, the default <code>StringsFileTextProvider</code> will be a good choice for
nearly all users. The only reason you might have to create an own <code>TextProvider</code> is if you want a very custom localization strategy, such as
translating text automatically through AI.</p>
<p>Assets are provided by <code>AssetProvider</code>s. In contrast to the <code>TextProvider</code>, you might very well create your own <code>AssetProvider</code>.
For your convenience, Yarn Spinner already ships with an <code>AudioAssetProvider</code> that you can use for voice lines and a <code>FileExtensionAssetProvider</code>
that can load any asset based on naming conventions and file extensions. See the chapter <a href="bevy_plugin/assets.html">Assets</a>.</p>
<p>Text and asset providers can be set through the builder API and accessed later with <code>DialogRunner::text_provider()</code> and <code>DialogRunner::asset_providers()</code>. If you know the exact type <code>T</code> of <code>AssetProvider</code> you
want, you can call <code>DialogRunner::asset_provider::&lt;T&gt;()</code> instead.</p>
<h2 id="builder-api"><a class="header" href="#builder-api">Builder API</a></h2>
<p>As mentioned in the beginning of this chapter, a <code>DialogRunner</code> can be modified or extended on creation
by using <code>YarnProject::build_dialog_runner()</code>. In fact, <code>YarnProject::create_dialog_runner()</code> is nothing but a shorthand for <code>YarnProject::build_dialog_runner().build()</code>.</p>
<p>You can use the builder API to inject your own implementations of traits used for the features presented in this chapter.
<code>DialogueRunnerBuilder::with_variable_storage</code> changes the underlying <code>VariableStorage</code> and <code>DialogueRunnerBuilder::with_text_provider</code> the <code>TextProvider</code>.
<code>DialogueRunnerBuilder::add_asset_provider</code> adds an <code>AssetProvider</code> to the set of asset providers called for each line presented to the player.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="localization-1"><a class="header" href="#localization-1">Localization</a></h1>
<p>If you only want to support a single language, you can safely ignore localization features.
As soon as you want to support <a href="bevy_plugin/assets.html">assets</a> or multiple languages however, you will need to use localization.
Fortunately Yarn Spinner makes this quite easy!</p>
<p>Let's first look at how to use localization and then explain what's going on under the hood.</p>
<h2 id="using-localization-the-easy-way"><a class="header" href="#using-localization-the-easy-way">Using Localization the Easy Way</a></h2>
<p>We specify our supported localizations when creating the <a href="bevy_plugin/compiling_yarn_files.html"><code>YarnSpinnerPlugin</code> (or using deferred compilation)</a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>YarnSpinnerPlugin::new().with_localizations(Localizations {
    base_localization: "en-US".into(),
    translations: vec!["de-CH".into()],
})
<span class="boring">}</span></code></pre></pre>
<p>The <em>base localization</em> is the language in which your Yarn files are already written.
In this case, we specified that our Yarn file was written in English as spoken in the USA.
The <em>translations</em> are all languages you want to support. Here, we want to support German as spoken in Switzerland.</p>
<p>Put the code shown above into the example used in the <a href="bevy_plugin/setup.html">setup</a> and run the game.</p>
<p>Now take a look at your Yarn file at <code>assets/dialog/example.yarn</code>.
You will see that your line of dialog will contain an autogenerated ID, for example:</p>
<pre><code class="language-diff"># assets/dialog/example.yarn
title: Start
---
- Hello World!
+ Hello World! #line:13032079 
===
</code></pre>
<p>This ID uniquely references this line across translations.
For the sake of clarity, we will use diff highlighting throughout this chapter.
In case you're not familiar with this look, for our purposes the red line started by "- " shows how the line looked like before a change,
while the green line started by "+ " shows how the line looks like after the change. The "- " and "+ " are just visual indicators and not actually part
of the files, so don't let that confuse you!</p>
<p>You will probably also have noticed a new file in your assets that was not there before, namely "de-CH.strings.csv":</p>
<p><img src="bevy_plugin/strings_file_generated.png" alt="strings_file_generated.png" /></p>
<p>This file is called a <em>strings file</em>, because it contains translations of each <em>string</em> of text of your Yarn files.
Let's see what it contains:</p>
<pre><code class="language-csv">language,id,text,file,node,line_number,lock,comment
de-CH,line:13032079,Hello World!,example.yarn,Start,4,7f83b165,
</code></pre>
<p>Since this is a CSV, let's open it in an application that renders the content as a table:
<img src="bevy_plugin/strings_file_new.png" alt="strings_file_new.png" /></p>
<p>You can see that our line from before is in there! Notice how the <code>id</code> matches across the files.</p>
<p>This file will be populated with new entries as soon you change the Yarn files. Assuming that you
are using hot reloading as described in the <a href="bevy_plugin/setup.html">setup</a>, run your app again in case you closed it or advanced the dialog.
While you are greeted with the "Hello World!" message on screen, open the Yarn file and edit it. Let's add a new line:</p>
<pre><code class="language-diff"># assets/dialog/example.yarn
title: Start
---
Hello World! #line:13032079 
+ This is a brand new line of text
===
</code></pre>
<p>Save the file while the game is still running. You should see that our new line just got assigned an own line ID:</p>
<pre><code class="language-diff"># assets/dialogue/example.yarn
title: Start
---
Hello World! #line:13032079
- This is a brand new line of text
+ This is a brand new line of text #line:10414042 
===
</code></pre>
<p>In case you can't see this, your editor might still have the old state of the file cached. It usually helps to change focus, tab out to another window, or closing and reopening the editor.
The strings file should now also contain a new entry:</p>
<p><img src="bevy_plugin/strings_file_another_line.png" alt="strings_file_another_line.png" /></p>
<p>Let's translate some of this. Change the string "Hello World!" in this file to "Hallo Welt!", which is German, and save it:</p>
<p><img src="bevy_plugin/strings_file_translated.png" alt="strings_file_translated.png" /></p>
<p>The game will currently happily ignore this as by default it uses the base language, which means it will take
its text straight from the Yarn files. But we can easily switch the language:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_dialogue_runner(mut commands: Commands, project: Res&lt;YarnProject&gt;) {
    let mut dialogue_runner = project.create_dialogue_runner();
    dialogue_runner.start_node("Start");
    dialogue_runner.set_language("de-CH"); // Use our translation
    commands.spawn(dialogue_runner);
}
<span class="boring">}</span></code></pre></pre>
<p>Run the game again and you should be greeted by this text:
<img src="bevy_plugin/translated_line.png" alt="translated_line.png" /></p>
<p>Hurray! See how painless localization can be?</p>
<h2 id="languages"><a class="header" href="#languages">Languages</a></h2>
<p>Languages are specified according to IETF BCP 47.
You can add as many translations as you want. Each will receive an own strings file.</p>
<p>To switch languages at runtime, simply retrieve a <code>DialogRunner</code> through a Bevy query inside a system.
When you use <code>DialogRunner::set_language()</code> as shown above, you will set the language for both text and assets.
You can be more granular by using <code>DialogRunner::set_text_language()</code> and <code>DialogRunner::set_asset_language()</code> separately instead.
This allows you to support use cases such as showing the text in the player's native language and play voiceover sound in the original recorded language, which might be a different one.</p>
<h2 id="assets"><a class="header" href="#assets">Assets</a></h2>
<p>Since assets require using localization, they are searched for in folders named after the language they support.
For the example used throughout this chapter, the assets for the base localization would be searched for in <code>assets/dialog/en-US/</code>, while the assets for the <code>de-CH</code>
translation will be searched at <code>assets/dialog/de-CH/</code>. This is however more a convention than a rule, as a given <code>AssetProvider</code> is allowed to look for its assets wherever.
The asset providers shipped by Yarn Spinner will additionally expect assets to be named after the line ID they belong to. For example, the <code>AudioAssetProvider</code> would look for the
voice line reading our "Hello World!" line at <code>assets/dialog/en-US/13032079.mp3</code> for the base localization.</p>
<p>To read more about how to use assets, read the chapter <a href="bevy_plugin/./assets.html">Assets</a>.</p>
<h2 id="file-editing-workflow"><a class="header" href="#file-editing-workflow">File Editing Workflow</a></h2>
<p>The strings file can be freely edited by a translator in the <em>text</em> and <em>comment</em> fields.
While you can translate the texts yourself, the format being straightforward allows the translator to also be someone else that is not involved with the coding part of the game at all.</p>
<p>You might have some questions regarding what happens when one person edits a Yarn file while another edits the strings file. As a general rule,
the strings file will try to "keep up" with the Yarn file without ever destroying anything that was already translated.</p>
<p>As you've seen, new lines will be amended. If the Yarn file has a line edited, it will be changed in the strings file as well if it was not yet translated.
If there is already a translation, it will be marked by a "NEEDS UPDATE" prefix in the text. If a line was deleted in the Yarn file, it will also be deleted
in the strings file if it was untranslated. Otherwise, it will be left untouched.</p>
<p>Bottom line: if there's a translation, it will <strong>never</strong> be removed.</p>
<h2 id="shipping-the-game"><a class="header" href="#shipping-the-game">Shipping the Game</a></h2>
<p>Once you want to build your game for a release, you should disable the automatic file creation and editing.
To do this, add the following line to the plugin creation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>YarnSpinnerPlugin::new()
// ...
.with_development_file_generation(DevelopmentFileGeneration::None)
<span class="boring">}</span></code></pre></pre>
<p>This will change the behavior of missing translations to simply fall back to the base localization.</p>
<p>While you're on it, you might also want to disable Bevy's hot reloading.</p>
<h2 id="customization"><a class="header" href="#customization">Customization</a></h2>
<p>You may have wondered what the <code>.into()</code>s were for in the lines at the beginning of the chapter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>YarnSpinnerPlugin::new().with_localizations(Localizations {
    base_localization: "en-US".into(),
    translations: vec!["de-CH".into()],
})
<span class="boring">}</span></code></pre></pre>
<p>They're here because a localization is not just a string with a language code, but an entire struct, namely <code>Localization</code>.
You can construct this struct directly the path to the strings file and where assets are searched for.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assets-1"><a class="header" href="#assets-1">Assets</a></h1>
<p>While Bevy as a whole has assets, Yarn Spinner can associate specific assets with lines.
These are always <a href="bevy_plugin/./localization.html">localized</a>, such as voiceovers.</p>
<h2 id="using-metadata-instead-of-assets"><a class="header" href="#using-metadata-instead-of-assets">Using Metadata Instead of Assets</a></h2>
<p>Before we jump into assets, let's first help you out if you don't care about localization.
The mechanism in place for this is <em>line metadata</em>, which are strings you can add to Yarn lines after a hashtag:</p>
<pre><code class="language-text">title: Start
---
Granny: It's hard to believe that it's over, isn't it? #smiling
Granny: Funny how we get attached to the struggle. #laughing
Granny: Promise me that you'll take care of yourself, okay? #smiling
===
</code></pre>
<p>A <a href="bevy_plugin/./dialog_views.html">dialog view</a> will be able to read the metadata "smiling", "laughing", and "smiling" again from <code>LocalizedLine::metadata</code> and accordingly load things like character portraits.
These annotations will also be written into the "comment" field of strings files, which are explained in the chapter <a href="bevy_plugin/./localization.html">Localization</a>.</p>
<h2 id="asset-providers"><a class="header" href="#asset-providers">Asset Providers</a></h2>
<p>Assets are fetched from the filesystem by structs implementing <code>AssetProvider</code>. They need to be registered when creating a <code>DialogRunner</code>.
For example, if you use the <code>audio_assets</code> feature, you can register an asset provider for audio files by modifying the code found in the <a href="bevy_plugin/./setup.html">setup</a> like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_dialogue_runner(mut commands: Commands, project: Res&lt;YarnProject&gt;) {
    let mut dialogue_runner = project
        .build_dialogue_runner()
        .add_asset_provider(AudioAssetProvider::new())
        .build();
    dialogue_runner.start_node("Start");
    commands.spawn(dialogue_runner);
}
<span class="boring">}</span></code></pre></pre>
<p>⚠️ <strong>Note:</strong> The bundled example dialog view does not play any audio files, so you will need to write your own <a href="bevy_plugin/./dialog_views.html"><code>dialog view</code></a> to make use of this feature.</p>
<h2 id="todo"><a class="header" href="#todo">TODO</a></h2>
<ul>
<li>Explain where stuff is searched</li>
<li>Mention <code>FileExtensionAssetProvider</code></li>
<li>Mention you can write your own <code>AssetProvider</code></li>
</ul>
<p>Feel free to <a href="https://github.com/YarnSpinnerTool/YarnSpinner-Rust/edit/main/docs/src/bevy_plugin/assets.md">contribute</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variable-storage-1"><a class="header" href="#variable-storage-1">Variable Storage</a></h1>
<p>TODO (Feel free to <a href="https://github.com/YarnSpinnerTool/YarnSpinner-Rust/edit/main/docs/src/bevy_plugin/variable_storage.md">contribute</a>!)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-functions"><a class="header" href="#custom-functions">Custom Functions</a></h1>
<p>As mentioned in the chapter <a href="bevy_plugin/../yarn_files/functions.html">Functions</a>, Yarn can access user-defined functions.
A collection of functions is called a <em>library</em> and can be accessed through a <code>DialogRunner</code>.</p>
<h2 id="function-registration"><a class="header" href="#function-registration">Function Registration</a></h2>
<p>For an easy example, let's modify the code used in the <a href="bevy_plugin/./setup.html">setup</a> to provide a simple <code>pow</code> function to Yarn:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_dialogue_runner(mut commands: Commands, project: Res&lt;YarnProject&gt;) {
    let mut dialogue_runner = project.create_dialogue_runner();
    // Add our custom function to the dialogue runner
    dialogue_runner.library_mut().add_function("pow", pow);
    dialogue_runner.start_node("Start");
    commands.spawn(dialogue_runner);
}

fn pow(base: f32, exponent: f32) -&gt; f32 {
    base.powf(exponent)
}
<span class="boring">}</span></code></pre></pre>
<p>The following snippet is of special importance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dialogue_runner.library_mut().add_function("pow", pow);
<span class="boring">}</span></code></pre></pre>
<p>The first parameter of <code>add_function()</code> is the name of the function as seen by Yarn, <code>"pow"</code> in this case.
The second parameter is the Rust function that will be called in the background.
Here, we reference the function definition of <code>fn pow(...)</code>, but you could also register a lambda.</p>
<p>This <code>pow</code> function can now be called from the Yarn file like this:</p>
<pre><code class="language-text">title: Start
---
Two to the power of three is {pow(2,3)}
===
</code></pre>
<p>Which will result in the following output:
<img src="bevy_plugin/custom_fn.png" alt="custom_fn.png" /></p>
<h2 id="allowed-signatures"><a class="header" href="#allowed-signatures">Allowed Signatures</a></h2>
<p>Custom functions need to follow some rules. Don't worry, they're pretty lax.</p>
<ul>
<li>Their parameter and output types need to be primitive types or <code>String</code></li>
<li>Parameters are allowed to be references</li>
<li>Parameters can have the special type <code>YarnValue</code>, which stands for any input type.
Additionally, functions are assumed to have no side effects. You can read the full list of requirements in the docs for <code>YarnFn</code>.</li>
</ul>
<p>Here are some examples of valid functions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(a: f32, b: f32) -&gt; f32 {
    a + b
}

fn concat(a: &amp;str, b: &amp;str) -&gt; String {
    format!("{a}{b}")
}

fn greet(name: &amp;str, age: usize) -&gt; String {
    format!("Hello {name}, you are {age} years old!")
}

fn format_anything(value: YarnValue) -&gt; String {
    format!("Got the following value: {value}")
}
<span class="boring">}</span></code></pre></pre>
<p>If you need functions that have side effects, e.g. for manipulating the game world, use <a href="bevy_plugin/./custom_commands.html">custom commands</a> instead.</p>
<h2 id="size-constraints"><a class="header" href="#size-constraints">Size constraints</a></h2>
<p>Registered Rust functions can have a maximum of 16 parameters.
If you need more, you can wrap parameters in tuples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add((a, b): (f32, f32)) -&gt; f32 {
    a + b
}
<span class="boring">}</span></code></pre></pre>
<p>Tuples are treated as separate parameters when calling the function from Yarn:</p>
<pre><code class="language-text">title: Start
---
Two plus three is {add(2, 3)}
===
</code></pre>
<p>Since tuples can be nested, you can use have potentially infinite parameters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-commands"><a class="header" href="#custom-commands">Custom Commands</a></h1>
<p><a href="bevy_plugin/../yarn_files/commands.html">Commands</a> work very similar to Yarn <a href="bevy_plugin/../yarn_files/functions.html">functions</a>, but
use a different syntax and are able to modify the game world. As a consequence of their similarity,
registering custom commands is very similar to registering <a href="bevy_plugin/./custom_functions.html">custom functions</a>.</p>
<h2 id="command-registration"><a class="header" href="#command-registration">Command Registration</a></h2>
<p>Just as with Yarn functions, registration happens when creating a <code>DialogRunner</code>.
Let's again modify the example from the <a href="bevy_plugin/./setup.html">setup</a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_dialogue_runner(mut commands: Commands, project: Res&lt;YarnProject&gt;) {
    let mut dialogue_runner = project.create_dialogue_runner();
    // Add our custom command to the dialogue runner
    dialogue_runner
        .commands_mut()
        .add_command("print_addition", print_addition);
    dialogue_runner.start_node("Start");
    commands.spawn(dialogue_runner);
}

fn print_addition(In((a, b)): In&lt;(f32, f32)&gt;) {
    print!("{a} + {b} = {c}", c = a + b)
}
<span class="boring">}</span></code></pre></pre>
<p>We call the command like this:</p>
<pre><code class="language-text">title: Start
---
Let's print the addition of 1 and 3 in the console:
&lt;&lt;print_addition 1 3&gt;&gt;
===
</code></pre>
<p>You will have seen one crucial difference to Yarn functions immediately.
The parameters are not passed in directly to the Rust function, but are wrapped in an <code>In</code> struct.
This is because Rust functions that are registered as commands are always valid Bevy systems.
The <code>In</code> parameter just tells the function which values come from the Yarn file, but we can additionally query the Bevy world as we want:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_dialogue_runner(mut commands: Commands, project: Res&lt;YarnProject&gt;) {
    let mut dialogue_runner = project.create_dialogue_runner();
    // Add our custom command to the dialogue runner
    dialogue_runner
        .commands_mut()
        .add_command("insert_resource", insert_resource);
    dialogue_runner.start_node("Start");
    commands.spawn(dialogue_runner);
}

#[derive(Resource)]
struct Person {
    name: String,
    age: f32,
}

fn insert_resource(In((name, age)): In&lt;(String, f32)&gt;, mut commands: Commands) {
    commands.insert_resource(Person { name, age });
}
<span class="boring">}</span></code></pre></pre>
<p>which we call like this:</p>
<pre><code class="language-text">title: Start
---
Let's insert a resource into the Bevy world:
&lt;&lt;insert_resource "Bob" 42&gt;&gt;
===
</code></pre>
<h2 id="todo-1"><a class="header" href="#todo-1">TODO</a></h2>
<ul>
<li>Mention return types
<ul>
<li>Async or tasks</li>
</ul>
</li>
<li>Mention that we need an In param even if we don't populate it with any values</li>
</ul>
<p>Feel free to <a href="https://github.com/YarnSpinnerTool/YarnSpinner-Rust/edit/main/docs/src/bevy_plugin/custom_commands.md">contribute</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dialog-views"><a class="header" href="#dialog-views">Dialog Views</a></h1>
<p>TODO (Feel free to <a href="https://github.com/YarnSpinnerTool/YarnSpinner-Rust/edit/main/docs/src/bevy_plugin/dialog_views.md">contribute</a>!)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-without-bevy"><a class="header" href="#working-without-bevy">Working Without Bevy</a></h1>
<p>While we currently emphasize the use of the Bevy plugin, Yarn Spinner for Rust is a standalone library that can be used with any game engine (or none at all!).</p>
<p>While there is currently no in-depth documentation on this, our <a href="../../crates/yarnspinner/tests">test suite</a> should point you in the right direction.
If you want to port Yarn Spinner for Rust to another engine, feel free to reach out by <a href="https://github.com/YarnSpinnerTool/YarnSpinner-Rust/issues/new">creating an issue</a>!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
